{
    "collab_server" : "",
    "contents" : "source('modules/Classes/DPEngine.R')\n\nEstimators <- \n  setRefClass(\n    'Estimators',\n    fields = list(\n      iter.stop.threshold = 'numeric',\n      beta = 'numeric',\n      num.theta = 'numeric',\n      num.states = 'numeric',\n      num.actions = 'numeric',\n      num.obs = 'numeric',\n      dirichlet.alpha = 'numeric',\n      panel = 'data.frame',\n      times = 'list', \n      theta = 'list', #true theta and theta estimates\n      dp = 'DPEngine'\n    ),\n    methods = list(\n      initializeEstimators = function(){\n        iter.stop.threshold <<- 10^-9\n        times <<- as.list(NULL)\n        theta <<- as.list(NULL)\n        theta$true <<- rnorm(num.theta)\n        \n        dp <<- \n          DPEngine$new(\n            beta = beta,\n            num.states = num.states, \n            num.actions = num.actions, \n            num.theta = num.theta,\n            dirichlet.alpha = dirichlet.alpha\n          ) %T>% {\n            .$initializeDP()\n          }\n        \n        createPanel()\n      },\n      \n      createPanel = function() {\n        dp$calcDP_policy(theta$true)\n        panel <<-\n          dp$CCP %>%\n          rd(cbind) %>% {\n            colnames(.) <- NULL\n            .\n          } %>%\n          ad %>%\n          mt(state = row_number()) %>% {\n            ij(\n              ., \n              df(state = seq(num.states)) %>%\n                sn(num.obs, replace = TRUE) %>%\n                ct(state)\n            )\n          } %>%\n          dd('state', function(s){\n            rmultinom(1, size = s$n, prob = sl(s, -c(state, n))) %>% \n              ad %>%\n              mt(action = row_number()) %>%\n              rn(n = V1)\n          }) %>%\n          fl(n > 0)\n      },\n      \n      evaluateLikelihood = function(my.ccps){\n        seq(num.actions) %>%\n          ld(function(l){\n            dp$CCP[[l]] %>%\n              ad %>% \n              rename_(CCP = '.') %>%\n              mt(\n                state = row_number(),\n                action = l\n              )\n          }) %>%\n          ij(panel) %>% \n          sm(sum(n * log(CCP))) %>% \n          un\n      },\n      \n      runNFXP = function() {\n        dp$resetSystem()\n        rep(0, num.theta) %>%\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$calcDP_value(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$NFXP <<- .$par\n          }\n      },\n      \n      runNNFXP = function() {\n        dp$resetSystem()\n        rep(0, num.theta) %>%\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$calcDP_policy(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$NNFXP <<- .$par\n          }\n      },\n      \n      runNPL = function() {\n        theta$NPL <<- rep(0, num.theta)\n        dp$resetSystem()\n        dp$estimateInitialCCPs(panel)\n        nestedPsuedoLikelihoodStep <- function(){\n          dp$calcPolicyIterationMat()\n          theta$NPL %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                dp$payoff$updatePayoffs(theta)\n                dp$loadCCPs()\n                dp$operator_PI()\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$NPL <<- .$par\n            }\n          dp$saveCCPs()\n        }\n        delta = 1\n        while(max(delta) > iter.stop.threshold){\n          theta.l <- theta$NPL\n          nestedPsuedoLikelihoodStep()\n          delta <- max(abs(theta.l - theta$NPL))\n        }\n      },\n      \n      runNNPL = function() {\n        theta$NNPL <<- rep(0, num.theta)\n        dp$resetSystem()\n        nestedPsuedoLikelihoodStep <- function(){\n          theta$NNPL %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                dp$payoff$updatePayoffs(theta)\n                dp$updateCCPs()\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$NNPL <<- .$par\n            }\n          dp$updateValues_VI()\n        }\n        delta = 1\n        while(max(delta) > iter.stop.threshold){\n          theta.l <- theta$NNPL\n          nestedPsuedoLikelihoodStep()\n          delta <- max(abs(theta.l - theta$NNPL))\n        }\n        \n        theta$NNPL %>% #One final run for accuracy\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$calcDP_policy(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$NNPL <<- .$par\n          }\n      },\n      \n      runNFXP_timed = function(){\n        times$NFXP <<- system.time(runNFXP())\n      },\n      \n      runNPL_timed = function(){\n        times$NPL <<- system.time(runNPL())\n      },\n      \n      runNNFXP_timed = function(){\n        times$NNFXP <<- system.time(runNNFXP())\n      },\n      \n      runNNPL_timed = function(){\n        times$NNPL <<- system.time(runNNPL())\n      }\n    )\n  )",
    "created" : 1457814436089.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "483541404",
    "id" : "32E6C609",
    "lastKnownWriteTime" : 1457900178,
    "last_content_update" : 1457900178300,
    "path" : "~/Dropbox/code/victor/code/modules/Classes/Estimators.R",
    "project_path" : "modules/Classes/Estimators.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}