{
    "collab_server" : "",
    "contents" : "source('modules/Classes/DPEngine.R')\n\nEstimators <- \n  setRefClass(\n    'Estimators',\n    fields = list(\n      iter.stop.threshold = 'numeric',\n      beta = 'numeric',\n      num.theta = 'numeric',\n      num.states = 'numeric',\n      num.actions = 'numeric',\n      num.obs = 'numeric',\n      dirichlet.alpha = 'numeric',\n      panel = 'data.frame',\n      times = 'list', \n      theta = 'list', #true theta and theta estimates\n      dp = 'DPEngine'\n    ),\n    methods = list(\n      initializeEstimators = function(){\n        times <<- as.list(NULL)\n        theta <<- as.list(NULL)\n        theta$true <<- rnorm(num.theta)\n        \n        iter.stop.threshold <<- 10^-9\n        \n        dp <<- \n          DPEngine$new(\n            beta = beta,\n            num.states = num.states, \n            num.actions = num.actions, \n            num.theta = num.theta,\n            dirichlet.alpha = dirichlet.alpha\n          ) %T>% {\n            .$initializeDP()\n          }\n        \n        createPanel()\n      },\n      \n      createPanel = function() {\n        dp$solve_DP_shape(theta$true)\n        panel <<-\n          dp$CCP %>%\n          rd(cbind) %>% {\n            colnames(.) <- NULL\n            .\n          } %>%\n          ad %>%\n          mt(state = row_number()) %>% {\n            ij(\n              ., \n              df(state = seq(num.states)) %>%\n                sn(num.obs, replace = TRUE) %>%\n                ct(state)\n            )\n          } %>%\n          dd('state', function(s){\n            rmultinom(1, size = s$n, prob = sl(s, -c(state, n))) %>% \n              ad %>%\n              mt(action = row_number()) %>%\n              rn(n = V1)\n          }) %>%\n          fl(n > 0)\n      },\n      \n      evaluateLikelihood = function(my.ccps){\n        seq(num.actions) %>%\n          ld(function(l){\n            dp$CCP[[l]] %>%\n              ad %>% \n              rename_(CCP = '.') %>%\n              mt(\n                state = row_number(),\n                action = l\n              )\n          }) %>%\n          ij(panel, by = c('state', 'action')) %>% \n          sm(sum(n * log(CCP))) %>% \n          un\n      },\n      \n      runNFXP = function() {\n        dp$resetSystem()\n        rep(0, num.theta) %>%\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$solve_DP_full(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$NFXP <<- .$par\n          }\n      },\n      \n      runSNFXP = function() {\n        dp$resetSystem()\n        rep(0, num.theta) %>%\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$solve_DP_shape(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$SNFXP <<- .$par\n          }\n      },\n      \n      runNPL = function() {\n        \n        ####NOTE: The monte carlo simulation ran from a previous version. That version is in versions/Econmetrica_submission. It didn't include the final NPL_step(theta$NPL) call before the dp$saveCCPs() line. \n        ####Also, I canged the definition of SNPL since then. But SNPL doesn't ever converge to something nice, so I'm dropping it.\n        \n        NPL_step <- function(theta) {\n          dp$payoff$updatePayoffs(theta)\n          dp$loadCCPs()\n          dp$operator_PI()\n        }\n        \n        theta$NPL <<- rep(0, num.theta)\n        dp$resetSystem()\n        dp$estimateInitialCCPs(panel)\n        delta = 1\n        while(delta > iter.stop.threshold){\n          value.fn.l <- dp$value.fn\n          \n          dp$calcPolicyIterationMat()\n          theta$NPL %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                NPL_step(theta)\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$NPL <<- .$par\n            }\n          \n          NPL_step(theta$NPL)\n          dp$saveCCPs()\n          delta <- max(abs(value.fn.l - dp$value.fn))\n        }\n      },\n      \n      runSNPL = function() {\n        SNPL_step <- function(theta) {\n          dp$payoff$updatePayoffs(theta)\n          dp$loadValues()\n          dp$loadCCPs()\n          updateValues_VI(use.val.shape)\n          updateCCPs()\n        }\n        \n        theta$SNPL <<- rep(0, num.theta)\n        dp$resetSystem()\n        delta = 1\n        while(delta > iter.stop.threshold){\n          value.fn.l <- dp$value.fn\n          theta$SNPL %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                SNPL_step(theta)\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$SNPL <<- .$par\n            }\n          SNPL_step(theta$SNPL)\n          dp$saveValues()\n          dp$saveCCPs()\n          delta <- max(abs(value.fn.l - dp$value.fn))\n        }\n      },\n      \n      runNFXP_timed = function(){\n        times$NFXP <<- system.time(runNFXP())\n      },\n      \n      runNPL_timed = function(){\n        times$NPL <<- system.time(runNPL())\n      },\n      \n      runSNFXP_timed = function(){\n        times$SNFXP <<- system.time(runSNFXP())\n      },\n      \n      runSNPL_timed = function(){\n        times$SNPL <<- system.time(runSNPL())\n      },\n      \n      solve_DP_shape_timed = function(){\n        dp$resetSystem()\n        times$dp_shape_solution <<- system.time(dp$solve_DP_shape(theta$true))\n      },\n      \n      solve_DP_full_timed = function(){\n        dp$resetSystem()\n        times$dp_full_solution <<- system.time(dp$solve_DP_full(theta$true))\n      },\n      \n      resetBeta = function(new.beta){\n        beta <<- new.beta\n        dp$beta <<- beta\n      }\n    )\n  )",
    "created" : 1483073791326.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "619269601",
    "id" : "F34D6E9D",
    "lastKnownWriteTime" : 1483206039,
    "last_content_update" : 1483206039850,
    "path" : "~/Dropbox/code/victor/code/modules/Classes/Estimators.R",
    "project_path" : "modules/Classes/Estimators.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}