{
    "collab_server" : "",
    "contents" : "source('modules/Classes/DPEngine.R')\n\nEstimators <- \n  setRefClass(\n    'Estimators',\n    fields = list(\n      beta = 'numeric',\n      num.theta = 'numeric',\n      num.states = 'numeric',\n      num.actions = 'numeric',\n      num.obs = 'numeric',\n      dirichlet.alpha = 'numeric',\n      panel = 'data.frame',\n      times = 'list', \n      theta = 'list', #true theta and theta estimates\n      dp = 'DPEngine'\n    ),\n    methods = list(\n      initializeEstimators = function(){\n        times <<- as.list(NULL)\n        theta <<- as.list(NULL)\n        theta$true <<- rnorm(num.theta)\n        \n        dp <<- \n          DPEngine$new(\n            beta = beta,\n            num.states = num.states, \n            num.actions = num.actions, \n            num.theta = num.theta,\n            dirichlet.alpha = dirichlet.alpha\n          ) %T>% {\n            .$initializeDP()\n          }\n        \n        createPanel()\n      },\n      \n      createPanel = function() {\n        dp$solve_DP_shape(theta$true)\n        panel <<-\n          dp$CCP %>%\n          rd(cbind) %>% {\n            colnames(.) <- NULL\n            .\n          } %>%\n          ad %>%\n          mt(state = row_number()) %>% {\n            ij(\n              ., \n              df(state = seq(num.states)) %>%\n                sn(num.obs, replace = TRUE) %>%\n                ct(state)\n            )\n          } %>%\n          dd('state', function(s){\n            rmultinom(1, size = s$n, prob = sl(s, -c(state, n))) %>% \n              ad %>%\n              mt(action = row_number()) %>%\n              rn(n = V1)\n          }) %>%\n          fl(n > 0)\n      },\n      \n      evaluateLikelihood = function(my.ccps){\n        seq(num.actions) %>%\n          ld(function(l){\n            dp$CCP[[l]] %>%\n              ad %>% \n              rename_(CCP = '.') %>%\n              mt(\n                state = row_number(),\n                action = l\n              )\n          }) %>%\n          ij(panel) %>% \n          sm(sum(n * log(CCP))) %>% \n          un\n      },\n      \n      runNFXP = function() {\n        dp$resetSystem()\n        rep(0, num.theta) %>%\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$solve_DP_full(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$NFXP <<- .$par\n          }\n      },\n      \n      runSNFXP = function() {\n        dp$resetSystem()\n        rep(0, num.theta) %>%\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$solve_DP_shape(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$SNFXP <<- .$par\n          }\n      },\n      \n      runNPL = function() {\n        theta$NPL <<- rep(0, num.theta)\n        dp$resetSystem()\n        dp$estimateInitialCCPs(panel)\n        nestedPsuedoLikelihoodStep <- function(){\n          dp$calcPolicyIterationMat()\n          theta$NPL %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                dp$payoff$updatePayoffs(theta)\n                dp$loadCCPs()\n                dp$operator_PI()\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$NPL <<- .$par\n            }\n          dp$saveCCPs()\n        }\n        delta = 1\n        iter.stop.threshold <- 10^-10\n        while(max(delta) > iter.stop.threshold){\n          CCP.l <- dp$CCP\n          nestedPsuedoLikelihoodStep()\n          delta <- \n            map2(dp$CCP, CCP.l, ~ max(abs(.x - .y))) %>%\n            unlist %>%\n            max\n        }\n      },\n      \n      runSNPL = function() {\n        theta$SNPL <<- rep(0, num.theta)\n        dp$resetSystem()\n        nestedPsuedoLikelihoodStep <- function(){\n          theta$SNPL %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                dp$payoff$updatePayoffs(theta)\n                dp$updateCCPs()\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$SNPL <<- .$par\n            }\n          dp$updateValues_VI(use.val.shape = TRUE)\n        }\n        iter.stop.threshold <- 10^-6\n        delta = 1\n        while(max(delta) > iter.stop.threshold){\n          value.fn.l <- dp$value.fn\n          nestedPsuedoLikelihoodStep()\n          delta <- max(abs(value.fn.l - dp$value.fn))\n        }\n        \n        theta$SNPL %>% #One final run for accuracy\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$solve_DP_shape(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$SNPL <<- .$par\n          }\n      },\n      \n      runSNPL2 = function() {\n        theta$SNPL2 <<- rep(0, num.theta)\n        dp$resetSystem()\n        nestedPsuedoLikelihoodStep <- function(){\n          theta$SNPL2 %>% \n            optim(  \n              par = .,\n              method = 'BFGS',\n              control = list(fnscale=-1), #max likelihood\n              fn = function(theta){\n                dp$payoff$updatePayoffs(theta)\n                dp$loadValues()\n                dp$updateValues_VI(use.val.shape = TRUE)\n                dp$updateCCPs()\n                evaluateLikelihood()\n              }\n            ) %>% {\n              theta$SNPL2 <<- .$par\n            }\n          dp$saveValues()\n        }\n        iter.stop.threshold <- 10^-6\n        delta = 1\n        while(max(delta) > iter.stop.threshold){\n          value.fn.l <- dp$value.fn\n          nestedPsuedoLikelihoodStep()\n          delta <- max(abs(value.fn.l - dp$value.fn))\n        }\n        \n        theta$SNPL2 %>% #One final run for accuracy\n          optim(  \n            par = .,\n            method = 'BFGS',\n            control = list(fnscale=-1), #max likelihood\n            fn = function(theta){\n              dp$solve_DP_shape(theta)\n              evaluateLikelihood()\n            }\n          ) %>% {\n            theta$SNPL2 <<- .$par\n          }\n      },\n      \n      runNFXP_timed = function(){\n        times$NFXP <<- system.time(runNFXP())\n      },\n      \n      runNPL_timed = function(){\n        times$NPL <<- system.time(runNPL())\n      },\n      \n      runSNFXP_timed = function(){\n        times$SNFXP <<- system.time(runSNFXP())\n      },\n      \n      runSNPL_timed = function(){\n        times$SNPL <<- system.time(runSNPL())\n      },\n      \n      runSNPL2_timed = function(){\n        times$SNPL2 <<- system.time(runSNPL2())\n      },\n      \n      solve_DP_shape_timed = function(){\n        dp$resetSystem()\n        times$dp_shape_solution <<- system.time(dp$solve_DP_shape(theta$true))\n      },\n      \n      solve_DP_full_timed = function(){\n        dp$resetSystem()\n        times$dp_full_solution <<- system.time(dp$solve_DP_full(theta$true))\n      },\n      \n      resetBeta = function(new.beta){\n        beta <<- new.beta\n        dp$beta <<- beta\n      }\n    )\n  )",
    "created" : 1461345492791.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3687152093",
    "id" : "CFB63076",
    "lastKnownWriteTime" : 1462466752,
    "last_content_update" : 1462466766427,
    "path" : "~/Dropbox/code/victor/code/modules/Classes/Estimators.R",
    "project_path" : "modules/Classes/Estimators.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}